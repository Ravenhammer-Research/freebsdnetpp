/**
 * @file save_state_commands.cpp
 * @brief Net tool save state command implementations
 * @details Implementation of save state command handlers for the net tool
 *
 * @author paigeadelethompson
 * @year 2024
 */

#include <interface/bridge.hpp>
#include <interface/lagg.hpp>
#include <iostream>
#include <net_tool.hpp>
#include <routing/table.hpp>
#include <system/config.hpp>
#include <string>
#include <vector>

namespace net {

  bool NetTool::handleSaveState(const std::vector<std::string> &args) {
    if (args.size() < 2) {
      printError("Usage: save <state>");
      return false;
    }

    if (args[1] != "state") {
      printError("Only 'state' target is supported");
      return false;
    }

    try {
      // Generate net tool configuration commands
      std::cout << "# Generated network configuration commands" << std::endl;
      std::cout << "# Generated by libfreebsdnet++ net tool" << std::endl;
      std::cout << "# Pipe this output to: net -c -" << std::endl;
      std::cout << std::endl;

      // System configuration
      std::cout << "# System configuration" << std::endl;
      try {
        libfreebsdnet::system::SystemConfig config;
        
        // Get IP forwarding settings
        bool ipv4_forwarding = config.getIpForwarding();
        std::cout << "set system net.inet.ip.forwarding " << (ipv4_forwarding ? "1" : "0") << std::endl;
        
        bool ipv6_forwarding = config.getIp6Forwarding();
        std::cout << "set system net.inet6.ip6.forwarding " << (ipv6_forwarding ? "1" : "0") << std::endl;
        
        // Get FIB count
        int fib_count = config.getFibs();
        std::cout << "set system net.fibs " << fib_count << std::endl;
        
      } catch (const std::exception& e) {
        std::cout << "# Error reading system config: " << e.what() << std::endl;
      }
      std::cout << std::endl;

      // Get all interfaces
      auto interfaces = interfaceManager.getInterfaces();
      
      for (const auto& iface : interfaces) {
        std::cout << "# Interface: " << iface->getName() << std::endl;
        
        // Interface state
        if (iface->isUp()) {
          std::cout << "set interface " << iface->getName() << " state up" << std::endl;
        } else {
          std::cout << "set interface " << iface->getName() << " state down" << std::endl;
        }
        
        // Interface MTU
        std::cout << "set interface " << iface->getName() << " mtu " << iface->getMtu() << std::endl;
        
        // Interface FIB
        try {
          std::cout << "set interface " << iface->getName() << " fib " << iface->getFib() << std::endl;
        } catch (...) {
          std::cout << "set interface " << iface->getName() << " fib 0" << std::endl;
        }
        
        // Add addresses
        auto addresses = iface->getAddresses();
        for (const auto& addr : addresses) {
          std::cout << "set interface " << iface->getName() << " address " << addr.getCidr() << std::endl;
        }
        
        // Interface-specific configurations
        auto type = iface->getType();
        
        if (type == libfreebsdnet::interface::InterfaceType::BRIDGE) {
          std::cout << "# Bridge configuration for " << iface->getName() << std::endl;
          try {
            auto bridgeIface = dynamic_cast<libfreebsdnet::interface::BridgeInterface *>(iface.get());
            if (bridgeIface) {
              std::cout << "set bridge " << iface->getName() << " stp " << (bridgeIface->isStpEnabled() ? "enable" : "disable") << std::endl;
              
              // Get bridge members from groups
              auto groups = iface->getGroups();
              for (const auto& group : groups) {
                if (group != "all" && group != "bridge" && group != "member") {
                  std::cout << "set bridge " << iface->getName() << " addm " << group << std::endl;
                }
              }
            }
          } catch (const std::exception& e) {
            std::cout << "# Error reading bridge config: " << e.what() << std::endl;
          }
        } else if (type == libfreebsdnet::interface::InterfaceType::LAGG) {
          std::cout << "# LAGG configuration for " << iface->getName() << std::endl;
          try {
            auto laggIface = dynamic_cast<libfreebsdnet::interface::LagInterface *>(iface.get());
            if (laggIface) {
              // Get protocol
              auto proto = laggIface->getProtocol();
              std::string protocol = "unknown";
              switch (proto) {
              case libfreebsdnet::interface::LagProtocol::FAILOVER:
                protocol = "failover";
                break;
              case libfreebsdnet::interface::LagProtocol::FEC:
                protocol = "fec";
                break;
              case libfreebsdnet::interface::LagProtocol::LACP:
                protocol = "lacp";
                break;
              case libfreebsdnet::interface::LagProtocol::LOADBALANCE:
                protocol = "loadbalance";
                break;
              case libfreebsdnet::interface::LagProtocol::ROUNDROBIN:
                protocol = "roundrobin";
                break;
              default:
                protocol = "unknown";
                break;
              }
              std::cout << "set lagg " << iface->getName() << " protocol " << protocol << std::endl;
              
              // Get LAGG ports
              auto ports = laggIface->getPorts();
              for (const auto& port : ports) {
                std::cout << "set lagg " << iface->getName() << " addm " << port << std::endl;
              }
            }
          } catch (const std::exception& e) {
            std::cout << "# Error reading LAGG config: " << e.what() << std::endl;
          }
        }
        
        std::cout << std::endl;
      }

      // Get routing table for all FIBs
      std::cout << "# Routing table" << std::endl;
      
      // Default FIB (0)
      auto routes = routingTable.getEntries();
      for (const auto& route : routes) {
        std::cout << "set route " << route->getDestination();
        
        if (!route->getGateway().empty()) {
          std::cout << " " << route->getGateway();
        }
        
        if (!route->getInterface().empty()) {
          std::cout << " " << route->getInterface();
        }
        
        std::cout << std::endl;
      }
      
      // Other FIBs - get actual routes for each FIB
      std::cout << "# Additional FIBs" << std::endl;
      try {
        libfreebsdnet::system::SystemConfig config;
        int fib_count = config.getFibs();
        
        for (int fib = 1; fib < fib_count; fib++) {
          std::cout << "# FIB " << fib << " routes:" << std::endl;
          auto fib_routes = routingTable.getEntries(fib);
          for (const auto& route : fib_routes) {
            std::cout << "set route " << route->getDestination();
            
            if (!route->getGateway().empty()) {
              std::cout << " " << route->getGateway();
            }
            
            if (!route->getInterface().empty()) {
              std::cout << " " << route->getInterface();
            }
            
            std::cout << " fib " << fib << std::endl;
          }
        }
      } catch (const std::exception& e) {
        std::cout << "# Error reading FIB routes: " << e.what() << std::endl;
      }
      std::cout << std::endl;

      return true;
    } catch (const std::exception &e) {
      printError("Error: " + std::string(e.what()));
      return false;
    }
  }

} // namespace net
